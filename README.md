# GraphQL Tutorial in Ruby On Rails

This tutorial explains how to use GraphQL with two examples models: Product and User. We will show how to get the data using QueryTypes and how to create or update data using Mutations.
Additionally, we will make a simple authentication.  

### Characteristics

* Ruby On Rails version: 5.2.2 
* Database: MySql

### Steps to follow

Generate the project:

```
gem install bundler
gem install rails -v 5.2.2
rails new graphql-tutorial -d mysql
cd graphql-tutorial
bundle exec rails db:create
bundle exec rails server

```

GraphQL installation:

```
# Gemfile

gem 'graphql', '1.8.13'
bundle install
rails generate graphql:install
```

Generate the Product model:

```
rails g model Product code:string description:string
rake db:migrate 
```

Write seeds:

```ruby
# seeds.rb

Product.create! code: 'P1', description: 'Pencil p1'
Product.create! code: 'P2', description: 'Pencil p2'
```

Reload database with seeds:

```
rake db:reset
```

Write the Product Type. Here we define which Product fields are available to give.

```ruby
# app/graphql/types/product_type.rb
module Types
  class ProductType < BaseObject
    field :id, ID, null: false
    field :code, String, null: false
    field :description, String, null: false
  end
end
``` 

Route for allProducts:

```ruby
# app/graphql/types/query_type.rb
 
module Types
  class QueryType < Types::BaseObject
    # Add root-level fields here.
    # They will be entry points for queries on your schema.

    field :products, [ProductType], null: false

    def products
      Product.all
    end
  end
end
```

Write a Product Mutation.

First of all, remove the autogenerated mutation example in `app/graphql/types/mutation_type.rb`

From:

```ruby
# app/graphql/types/mutation_type.rb
  
module Types
  class MutationType < Types::BaseObject
    # TODO: remove me
    field :test_field, String, null: false,
      description: "An example field added by the generator"
    def test_field
      "Hello World"
    end
  end
end

```

To:

```ruby
# app/graphql/types/mutation_type.rb
 
module Types
  class MutationType < Types::BaseObject
  end
end

```

Then, write a BaseObject for Mutations. All mutations will inherit of this class:

```ruby
# app/graphql/mutations/base_mutation.rb
 
module Mutations
  class BaseMutation < GraphQL::Schema::Mutation
    null false
  end
end
```

Writing a Mutation for Product creation

```ruby
#app/graphql/mutations/create_product.rb
  
module Mutations
  class CreateProduct < BaseMutation
    argument :code, String, required: true
    argument :description, String, required: true

    type Types::ProductType

    def resolve(code, description)
      Product.create!(
          code: code,
          description: description
      )
    end
  end
end
```

Adding the 'routing' for the Product creation:

```ruby
# app/graphql/types/mutation_type.rb
module Types
  class MutationType < Types::BaseObject
    field :create_product, mutation: Mutations::CreateProduct
  end
end
```

GraphQL product creation Example:

```
mutation {
  createProduct(
    code: "L1T1",
    description: "Black pencil"
  ) {
    id
    code
    description
  }
}
```

Create a Mutation for Product updating:

```ruby
# app/graphql/mutations/update_product.rb

module Mutations
  class UpdateProduct < BaseMutation
    argument :id, ID, required: true
    argument :code, String, required: true
    argument :description, String, required: true

    type Types::ProductType

    def resolve(id:, code: nil, description: nil)

      product = Product.find_by!(id: id)

      product.update(
          code: code,
          description: description
      )
      product
    end
  end
end 
```

Adding the 'routing' for the Product creation:

```ruby
# app/graphql/types/mutation_type.rb
module Types
  class MutationType < Types::BaseObject
    field :create_product, mutation: Mutations::CreateProduct
    field :update_product, mutation: Mutations::UpdateProduct
  end
end
```

Generate the User Model:

```
rails generate model User name email password_digest
rake db:migrate
```

Function `has_secure_password` adds basic authentication methods to User model.

```ruby
# app/models/user.rb
class User < ApplicationRecord
  has_secure_password

  validates :name, presence: true
  validates :email, presence: true, uniqueness: true
end

```

Add Bcrypt to Gemfile:

```
gem 'bcrypt', '~> 3.1.7' 
```

Install the gem.

```
bundle install
```

Write a Type for User:

```ruby
# app/graphql/types/user_type.rb
module Types
  class UserType < BaseObject
    field :id, ID, null: false
    field :name, String, null: false
    field :email, String, null: false
  end
end

```

Write a Mutation for User creation:

```ruby
module Mutations
  class CreateUser < BaseMutation
    argument :name, String, required: true
    argument :email, String, required: true
    argument :password, String, required: true

    type Types::UserType

    def resolve(name, email, password)
      User.create!(
          name: name,
          email: email,
          password: password)
      )
    end
  end
end
```

Add the route for the User creation:

```ruby
# app/graphql/types/mutation_type.rb
module Types
  class MutationType < Types::BaseObject
    field :create_user, mutation: Mutations::CreateUser
    field :create_product, mutation: Mutations::CreateProduct
  end
end

```

GraphQL user creation Example:

```
mutation {
  createUser(
    name: "Peter",
    email: "peter@gmail.com",
    password: "123456"
  ) {
    id
  }
}
```

List Users. We add a all_users 'route' in QueryType

```ruby
# app/graphql/types/query_type.rb
module Types
  class QueryType < Types::BaseObject
    
    # Products
    field :products, [ProductType], null: false

    def products
      Product.all
    end
    
    
    # Users
    field :users, [UserType], null: false
    
    def users
      User.all
    end
  end
end
```

Sign in user

```ruby
# app/graphql/mutations/sign_in_user.rb
module Mutations
  class SignInUser < BaseMutation
    null true

    argument :email, String, required: true
    argument :password, String, required: true

    field :token, String, null: true
    field :user, Types::UserType, null: true

    def resolve(email: nil, password: nil)
      return unless email && password

      user = User.find_by email: email

      # ensures we have the correct user
      return unless user
      return unless user.authenticate(password)

      # use Ruby on Rails - ActiveSupport::MessageEncryptor, to build a token
      crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
      token = crypt.encrypt_and_sign("user-id:#{ user.id }")

      { user: user, token: token }
    end
  end
end
```

Add route for sign user in:

```ruby
# app/graphql/types/mutation_type.rb
module Types
  class MutationType < Types::BaseObject
    field :create_user, mutation: Mutations::CreateUser
    field :create_product, mutation: Mutations::CreateProduct
    field :sign_in_user, mutation: Mutations::SignInUser
  end
end

```

Example for user login:

```
mutation {
  signInUser(email: "axeltaglia@gmail.com", password: "123456")
  {
    token
    user {
      id
    }
  }
}
```


Using token in other services

GraphQL provides a context in graphql_controller. We can customize this controller passing the session and the current_user for each query and mutation calls.

First, update graphql_controller:

```ruby
class GraphqlController < ApplicationController
  def execute
    variables = ensure_hash(params[:variables])
    query = params[:query]
    operation_name = params[:operationName]
    context = {
      ####################################################
      session: session,
      current_user: current_user
      ####################################################
    }
    result = GraphqlTutorialSchema.execute(query, variables: variables, context: context, operation_name: operation_name)
    render json: result
  rescue => e
    raise e unless Rails.env.development?
    handle_error_in_development e
  end

  private

  ########################################################
  # gets current user from token stored in the session
  def current_user
    # if we want to change the sign-in strategy, this is the place to do it
    return unless session[:token]

    crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
    token = crypt.decrypt_and_verify session[:token]
    user_id = token.gsub('user-id:', '').to_i
    User.find_by id: user_id
  rescue ActiveSupport::MessageVerifier::InvalidSignature
    nil
  end
  #######################################################

  # Handle form data, JSON body, or a blank value
  def ensure_hash(ambiguous_param)
    case ambiguous_param
    when String
      if ambiguous_param.present?
        ensure_hash(JSON.parse(ambiguous_param))
      else
        {}
      end
    when Hash, ActionController::Parameters
      ambiguous_param
    when nil
      {}
    else
      raise ArgumentError, "Unexpected parameter: #{ambiguous_param}"
    end
  end

  def handle_error_in_development(e)
    logger.error e.message
    logger.error e.backtrace.join("\n")

    render json: { error: { message: e.message, backtrace: e.backtrace }, data: {} }, status: 500
  end
end

```

Then, update sign_in_user.rb mutation where we store in the context session, the token.

```ruby

 def resolve(email: nil, password: nil)
   # ... code
   crypt = ActiveSupport::MessageEncryptor.new(Rails.application.credentials.secret_key_base.byteslice(0..31))
   token = crypt.encrypt_and_sign("user-id:#{ user.id }")

   ###########################################
   context[:session][:token] = token
   ###########################################
   # ... code   

 end 
```

### Conclusions 

GraphQL replaces RESTful queries. It is very useful when the client needs to ask for a specific set of fields to the same web service.